# Курс по CSS: конспект

Расшифровка:

CSS = Cascading Style Sheets = Каскадная Таблица Стилей

Другими словами, это язык стилей для объектов html. 

Для написания кода на CSS можно использовать любой текстовый редактор.

### Комментарии внутри CSS-файла

```
/* 
...
*/
```

## Способы подключение CSS к HTML-документу

#### С помощью атрибута style

Добавляем к какому-то конкретному тегу атрибут style. (Делается внутри html-документа)

Например:
```
<p style="тут можно написать CSS-код, который применится к этому тегу"> блаблабла </p>
```

В CSS есть наслеование: если применить style к какому-то тегу, то style применится и к тегу, который находится внутри этого тега.

Подключение CSS через атрибут style обычно используется, когда нужно добавить небольшое количество стилей (один-два).

#### С помощью тега style

Тег style прописывается внутри head. Написание его в теге body - грубая ошибка.

Синтаксис на примере:
```
<style>
p {
    color: red
}
</style>
```
Здесь мы написали, что для всех тегов p нужно использовать определённый стиль (красный цвет).

Можно также указать несколько стилей для одного тега:
```
<style>
p {
    color: red;
    ещё один стиль;
    ещё один стиль
}
</style>
```

#### С помощью отдельного CSS-файла со стилями

Это наиболее правильный вариант подключения, т.к. здесь не будут смешиваться HTML и CSS.

Внутри этого файла пишется код, аналогично тому, что мы писали в теге style.

Для такого файла обычно создаётся отдельная папка, и обычно он называется main (название не так важно, главное расширение CSS).

`Как подключить CSS-файл к HTML-файлу:`
```
<link rel="stylesheet" href="путь к файлу"
```
Этот тег прописывается в head.

## Селекторы для выборки

(или как указывать, к каким именно объектам подключать стили)

Например, если мы пишем, что ко всем таким-то тегам нужно подключить определённый стиль, то здесь название тега - селектор.

### Другие способы

#### Классы

Достигается добавлением атрибута class к какому-либо тегу, например:
```
<p class="название_класса">текст</p>
```

Тогда в CSS-файле мы можем обратиться к этому классу:
```
.название_класса {
    какой-то стиль;
}
```

#### Идентификаторы

То же самое, что и классы. Единственное отличие от классов: идентификатор всегда должен быть один на странице (*).

Идентификатор добавляется через атрибут id. Пример:
```
<p id="конкретный_идентификатор">что-то</p> 
```

(*) То есть id с конкретным значением может быть только один такой на странице. Точно такой же id нельзя добавлять к другим элементам на странице (обработается браузером, но всё равно считается ошибкой, так нельзя).

Как обратиться к идентификатору в CSS-файле:
```
#конкретный_идентификатор {
    какой-то стиль;
}
```

#### Вложенные селекторы выбора

В случае, если мы хотим, например, добавить стиль по названию тега, но хотим, чтобы он применялся не ко всем тегам с таким названием, а, например, к тегам с таким названием, которые содержатся внутри определённого тега.

Синтаксис:
```
название_внешнего_тега назв_внутр_тега {
    стиль;
}
```

Вложенность можно сделать ещё более многоуровневой (тег, в нём тег, в нём ещё тег...)

#### Группировка 

Если мы хотим добавить какой-то стиль к двум объектам, то мы можем:
+ добавить один и тот же class к двум различным объектам
+ использовать группировку

Группировка: просто через запятую перечисляем, куда добавлять стиль. Пример в файлике. 

При данном подходе разрешается смешивать различные типы селекторов, например:
```
div, .class, #id, div p {
    какой-то стиль;
}
```

## Подчёркивание текста

Задать линию подчёркивания (верхнее подчёркивание тут тоже есть):
```
какой-то класс или id или название {
    text-decoration: выбранный_параметр;
}
```

Задать цвет линии подчёркивания:
```
какой-то класс или id или название {
    text-decoration: выбранный_параметр;
}
```

## Задать тип курсора

Используется, например, при изменении состояния объекта после какого-то действия (навели => курсор поменялся).

Синтаксис:
```
какой-то класс или id или название {
    cursor: выбранный_параметр;
}
```

Здесь выбранный параметр - нужный нам вид курсора; например, pointer ("активная мышка", чаще всего используется как изменение курсора после наведения на ссылку)

В качестве курсора можно установить любую картинку:
```
какой-то класс или id или название {
    cursor: url('путь');
}
```

## Задний фон:

Задать цвет фона какого-то объекта:

```
какой-то класс или id или название {
    background-color: выбранный_параметр;
}
```

Если в используемом текстовом редакторе нет функции выбора цвета, то можно загуглить "color picker", выбрать цвет, скопировать хеш и указать его в качестве выбранного параметра.

Если указать фон для тега body, это будет фон всей страницы.

## Псевдоклассы 

С помощью псевдоклассов можно управлять свойствами объекта в различных его состояниях. Таким образом мы можем, например, задать объекту смену цвета при наведении на него, и т.п.

Синтаксис:
```
.название_класса {
    какие-то свойства;
}

.название_этого_же_класса:состояние_объекта {
    какие-то свойства и стили;
}
```
Здесь сначала прописываются свойства объекта класса, если с объектом ничего не делать, а потом снова пишутся свойства для того же класса, но уже для изменённого его состояния, и это состояние записывается через двоеточие. Эти состояния и называются псевдоклассами.

Некоторые псевдоклассы:

+ hover - изменение свойств объекта при наведении на него
+ active - изменение свойств объекта при нажатии на него
+ visited - обычно применяется к ссылкам; позволяет добавлять стили к тем ссылкам, по которым мы уже переходили
+ focus - когда навели мышку на какое-нибудь текстовое поле и готовы писать там текст
+ Если написать 
    ```
    input:disabled {
        стили;
    }
    ```, 
    то мы обратимся ко всем тегам input, для которых указан атрибут disabled (неактивный).
    Если написать 
    ```
    input:enabled {
        стили;
    }
    ```, 
    то мы обратимся ко всем тегам input, для которых указан атрибут enabled(активный).
+ empty - обратиться ко всем пустым объектам класса. Например, обратиться ко всем пустым абзацам:
```
p.class:empty {
    стили;
}
```
+ выбрать все НЕпустые абзацы:
```
p.class:not(:empty) {
    стили;
}
```
+ Чтобы обратиться к первому объекту всего html-документа (например, только к первому из всех абзацев):
```
тип_объекта:first-of-type {
    стили;
}
```
Типом объекта может быть, например, название тега.
+ last-of-type работает аналогично, но наоборот.

Псевдоклассы можно добавлять к любым объектам.

#### Обратиться ко всем тегам по классу

Обратиться ко всем тегам одного названия, у которых класс такой-то:

```
название_тега.название_класса {
    стили;
}
```

Например, если нам нужны все абзацы класса class:

```
p.class {
    стили;
}
```

## Псевдоэлементы

Псевдоэлементы позволяют работать с определённой частью текста внутри html-объекта.

Псевдоэлементы прописываются после идентификатора через два двоеточия:

```
#id::название_псевдоэлемента {
    ...
}
```

Некоторые псевдоэлементы:
+ after - этот псевдоэлемент обращается к невидимой части, которая стоИт за самим объектом
Применение after:
```
#id::after {
    content: 'тут можно указать, какой текст будет выводиться после объекта';
}
```
Текст, добавленный таким образом, пользователь не сможет выделить.
Чтобы добавить стили к тексту, добавленному через after, прописываем их тут же:
```
#id::after {
    content: 'тут можно указать, какой текст будет выводиться после объекта';
    стили;
}
```
При помощи after также можно после какого-то элемента вывести значение другого элемента, например, атрибута title:
```
тег.класс:псевдокласс::after {
    content: attr(title);
}
```
+ before - аналогично after, только наоборот:
```
#id::before {
    content: 'тут можно указать, какой текст будет выводиться перед объектом';
}
```
+ first-letter - псевдоэлемент для обращения к первой букве (например, первой букве абзаца)
+ first-line псевдоэлемент для обращения к первой строке (например, первой строке абзаца)

## Фоновые картинки

Чтобы добавить картинку в качестве фона, добавляем тегу следующее свойство:

```
тег {
    background-image: url();
}
```

Если добавить это свойство тегу body, мы установим картинку в качестве основного фона всей страницы.

Мы можем также указать различные свойства для картинки, установленной в качестве фона:

```
body {
    background-image: url('путь или ссылка');
    background-repeat: выбранный_параметр;
    background-position: выбранный_параметр;
    background-size: выбранный_параметр;
    background-attachment: выбранный_параметр;
}
```

Здесь:
+ background-repeat - сколько раз картинка будет повторяться на странице;
например, мы можем сделать так, чтобы она не повторялась, или повторялась по какой-то из координат (x или y).
+ background-position - где конкретно картинка должна находиться (прижиматься к одной из сторон/по центру/др.)

Как можно сократить запись:

```
body {
    color: выбранный_параметр;
    background: url('путь или ссылка') no-repeat center center;
}
```
Здесь первый center - по центру по горизонтали, второй center - по центру по вертикали.

Как указать высоту тега:
```
тег {
    height: 100vh;
}
```
Так мы можем указать, сколько процентов экрана занимает содержимое тега, например, тега body.

+ background-size - указать размер фоновой картинки; например, если установить параметр cover, то картинка растянется на 100% ширины родительского объекта.
+ background-attachment - если в качества параметра установить fixed, то когда пользователь будет скроллить страницу, картинка будет оставаться фиксированой. Применяется, когда картинка не на всю страницу.

## Стили для текста

text-align - выравнивание текста.

font-size - размер текста; варианты:

```
font-size: СКОЛЬКО-ТОpx <!--в пикселях--> 
<!--или-->
font-size: large <!--словами-->
<!--или-->
font-size: 2em <!--в относительных единицах; здесь мы увеличили первоначальный размер текста в два раза-->
```

font-style - если выбрать italic, текст будет наклонным (курсив).

font-weight - указать, насколько жирным будет шрифт.

Поменять шрифт: font-family

Если использовать свой шрифт, который есть только на конкретном компьютере, то он только на этом компьютере и будет работать. 

Чтобы украсть шрифт, нужно скачать его на google fonts (либо нажать "download family", либо выбрать вкладку "import", скопировать оттуда код с собакой и вставить в самый верх css-файла (просто собака и то, что с ней, не надо никаких селекторов)).

Чтобы подключить украденный шрифт:

```
объект {
    font-family: (**)
}
```
(**) То, что после двоеточия, полностью копируем и вставляем из "CSS rules to specify families"

На этом сайте также показано, как выглядит выбранный шрифт при разной степени жирности; можно взять понравившееся значение жирности оттуда и установить через font-weight.

text-transform - указать, в каком регистре должны быть символы текста
(capitalize - первый символ каждого слова - в верхнем регистре)

word-spacing: СКОЛЬКО-ТОpx - пространство между словами (в пикселях); аналогично, letter-spacing - пространство между символами. (Здесь можно указывать отрицательное значение, и тогда они будут залезать друг на друга)

line-height - расстояние между строками (указывается в пикселях)

cursor - какой курсор будет при наведении на текст

## Стили для блоков

```
#id_блока {
    
    height: 100px <!-- или 50vh - в процентах от экрана; цифры тут рандомные; для высоты лучше использовать vh, а не % -->

    width: 100px <!-- или 50% - в процентах от экрана; цифры тут рандомные; для ширины лучше использовать %, а не vw -->

    border: 2px solid цвет
    
    <!-- border - обводка; 
    ширина указывается в пикселях; потом пишем тип обводки (solid - сплошная обводка); 
    добавить обводку только к определённой стороне блока можно с помощью не border, а "border-выбранный_параметр"; 
    если нужно добавить обводку ко всем сторонам, кроме одной, то добавляем её, а потом вводим "border-сторона_которую_не_Надо_обводить": 0; 
    также можно через border-width, border-style и им подобные команды указать свойства всей обводки блока --> 

    border-radius: ...px;
    <!-- это скругление углов; применяется ко всем углам -->

    border-radius: ...px ...px;
    <!-- Углы, стоящие на концах разных диагоналей, скруглятся на указанное для каждой из них число пикселей; каждое из значений применяется к двум противоположным углам; и так далее, по аналогии, можно указать 3 или 4 параметра -->

    opacity: 1;
    <!-- прозрачность; по умолчанию здесь стоит 1 = полностью непрозрачный объект; 0 = полностью прозрачный; значение между 0 и 1 указывается десятичной дробью через точку -->

    margin: ...px;
    <-- внешний отступ применяется одновременно ко всем сторонам на одинаковое количество пикселей; 
    через margin-сторона можно указать, куда конкретно нужно добавить внешний отступ;
    если просто добавить два значения, первое будет для верха и низа, второе - для боковых сторон; 
    3 и 4 значения также можно установить аналогично скруглению -->

    padding: ...px; 
    <!-- внутренний отступ; работает абсолютно аналогично внешнему -->

}
```

Свойства стрОчных и блочных объектов очень отличаются; нельзя просто применить к ним один и тот же класс. Нам нужно обратиться к классу и указать, что из себя представляют объекты, для которых указан этот класс:

```
.class {
    ....
    какие-то стили;
    ....
    display: block;
}
```

Тогда строчный объект, если приписать ему класс, для которого указан display: block, начнёт теперь вести себя как блок. (и наоборот; и с другими типами так тоже можно) 

## Как убрать отступы в браузере

Любой браузер по умолчанию ставит отступы по краям страницы. Чтобы их убрать, обращаемся либо к тегу body, либо к тегу html, либо, в наилучшем варианте, сделать в начале CSS-файла так:

```
* {
    margin: 0;
    padding: 0;
}
```
/ * - мы обратились ко всем html-объектам

Мы поставили значения по нулям, то есть по умолчанию у нас будут нулевые отступы.

## Позиционирование блоков

#### float - поставить блоки на одну линию, а не друг под другом

Пусть у нас есть два блока одного класса. У каждого из них свой id: first и second.

По умолчанию они будут находиться один под другим (вертикально).

Тогда:

```
#first {
    float: left
}
```

Тем самым мы сделали так, чтобы первый блок был прижат к левой стороне, а остальные должны обтекать его справа.

Однако, чтобы не получалась хрень, нужно, если для одного блока указан float, указать float и для другого:

```
#second {
    float: left
}
```
Второй блок теперь тоже с позиционированием слева. Теперь они "на равных правах" и отображаются в одну линию.

Мы можем позиционировать блоки не только слева.

## z-индекс

Объект, созданный позже, находится выше в иерархии объектов. Чтобы это поменять, используется z-индекс:

```
#id_первого {
    position: relative;
    z-index: 1;
}
#id_второго {
    z-index: 0;
}
```

То есть мы указали слой, то есть, какой объект будет поверх другого, если они будут наслаиваться друг на друга. Здесь мы поставили первый выше второго.